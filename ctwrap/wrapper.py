"""The :mod:`wrapper` module defines a :class:`Simulation` object that
wraps simulation modules.

Class Definition
++++++++++++++++
"""
from pathlib import Path
import importlib
import h5py
import json
import warnings

from typing import Dict, Any, Optional, Union


# ctwrap specific import
from .parser import Parser


class Simulation(object):
    """
    The Simulation class wraps simulation modules into a callable object.

    Simulation modules specify tasks to be run in a batch job; a simulation
    module needs to define methods ``defaults`` (default parameters),
    ``run`` (running of batch calculations) and ``save`` (saving output;
    optional).

    .. note:: :class:`Simulation` objects should be instantiated using
        the :meth:`from_module` method.

    Attributes:
        data: Dictionary containing simulation results.

    Arguments:
        module: Handle name or handle to module running the simulation
        output: Used by :class:`SimulationHandler`
    """

    def __init__(self, module: str, output: Dict[str, Any]=None):
        """Constructor for `Simulation` object."""

        assert isinstance(module, str), 'need module name'

        self._module = module
        self._output = output
        self.data = None # type: Dict
        self._errored = False

        # ensure that module is well formed
        mod = self._load_module()
        msg = 'module `{}` is missing attribute `{}`'
        for attr in ['defaults', 'run']:
            assert hasattr(mod, attr), msg.format(module, attr)

    @classmethod
    def from_module(cls,
                    module: str,
                    output: Optional[Dict[str, Any]] = None) -> \
            Union['Simulation', Dict[str, Any], str]:
        """
        Alternative constructor for `Simulation` object.

        The :meth:`from_module` method is intended as the main route for the creation of
        `Simulation` objects. For example:

        .. code-block:: Python

           # creates a simulation object with the simulation module `minimal`
           sim = ctwrap.Simulation.from_module(ctwrap.modules.minimal)

        Arguments:
           module (module): handle name or handle to module running the simulation
           output (dict):  output hdf file information generated by `SimulationHandler`
        """

        # create a name that reflect the module name (CamelCase)
        if isinstance(module, (str, Path)) and Path(module).is_file():
            name = Path(module).stem
            module = '{}'.format(Path(module))
        elif isinstance(module, str):
            name = module.split('.')[-1]
        else:
            name = module.__name__.split('.')[-1]
            module = module.__name__
        name = ''.join([m.title() for m in name.split('_')])

        return type(name, (cls,), {})(module, output)

    def _load_module(self):
        """Load simulation module"""
        if Path(self._module).is_file():
            fname = Path(self._module)
            # https://stackoverflow.com/questions/19009932/import-arbitrary-python-source-file-python-3-3
            spec_file = importlib.util.spec_from_file_location(fname.stem, fname)
            spec_module = importlib.util.module_from_spec(spec_file)
            spec_file.loader.exec_module(spec_module)
            return spec_module

        return importlib.import_module(self._module)

    def run(self, name: Optional[str] = 'defaults',
            config: Optional[Dict[str, Any]] = None,
            **kwargs: str) -> None:
        """
        Runs the simulation module's run method.

        This :meth:`run` method is used to call the simulation module's run method.
        If a simulation object ``sim`` was created with simulation module
        ``minimal``, then calls this :meth:`run` method calls ``run`` method in
        simulation module ``minimal``. A simple usage example is:

        .. code-block:: Python

            sim.run()

        Arguments:
            name: Name of simulation run
            config: Configuration used for simulation
            **kwargs: Optional parameters passed to the job
        """

        module = self._load_module()

        if config is None:
            config = module.defaults()
        config = Parser(config)

        try:
            self.data = module.run(name, **config, **kwargs)
            self._errored = False
        except Exception as err:
            # Convert exception to warning
            msg = "Simulation of '{}' for '{}' failed with error message:\n{}".format(module.__name__, name, err)
            warnings.warn(msg, RuntimeWarning)
            self.data = {name: (type(err).__name__, str(err))}
            self._errored = True

    def defaults(self) -> Dict[str, Any]:
        """Pass-through returning simulation module defaults as a dictionary"""
        module = self._load_module()
        return module.defaults()

    def _save(self, mode="a", task=None, **kwargs: str) -> None:
        """
        Save simulation data (hidden)

        The :meth:`_save` is used to call the simulation module's save method.

        Arguments:
            **kwargs (optional): keyword arguments
        """

        if self._output is None:
            return

        output = self._output.copy()

        filename = output.pop('file_name')

        if filename is None:
            return

        filepath = output.pop('path')
        formatt = "." + output.pop('format')
        force = output.pop('force_overwrite')

        if filepath is not None:
            filename = Path(filepath) / filename

        # file check
        fexists = Path(filename).is_file()

        if fexists:
            with h5py.File(filename, 'r') as hdf:
                for group in hdf.keys():
                    if group in self.data and mode == 'a' and not force:
                        msg = 'Cannot overwrite existing ' \
                              'group `{}` (use force to override)'
                        raise RuntimeError(msg.format(group))
                    elif group in self.data and mode == 'a' and force:
                        mode = 'w'

        output.pop('name')
        output.update(mode=mode)

        if formatt in ('.h5', '.hdf', '.hdf5'):
            module = self._load_module()
            if hasattr(module, 'save'):
                if self._errored:
                    with h5py.File(filename, mode) as hdf:
                        for group, err in self.data.items():
                            grp = hdf.create_group(group)
                            grp.attrs[err[0]] = err[1]
                else:
                    module.save(filename, self.data, task, **output)
            else:
                raise AttributeError("{} simulation module has no method 'save' "
                                     "but output format was defined in configuration "
                                     "file".format(self._module))
        else:
            raise ValueError("Invalid file format {}".format(formatt))

    def _save_metadata(self,
                       output: Optional[Dict[str, Any]] = None,
                       metadata: Optional[Dict[str, Any]] = None,
                       ) -> None:
        """
        Modules saves the input file as an attribute after the
        batch simulation has been completed

        This method calls the
        :py:func:`~ctwrap.parser.save_metadata` method.

        Arguments:
            metadata (dict): data to be saved
            output (dict): output file information
        """

        if output is None:
            output = self._output

        if metadata is None or output is None:
            return

        def save_metadata(output: Dict[str, Any],
                        metadata: Dict[str, Any]) -> None:
            """Function save metadata as attributes to file

            Arguments:
                output: file information
                metadata: metadata
            """

            oname = output['file_name']
            opath = output['path']
            #formatt = output['format']
            #force = output['force_overwrite']

            if oname is None:
                return
            if opath is not None:
                oname = Path(opath) / oname

            with h5py.File(oname, 'r+') as hdf:
                for key, val in metadata.items():
                    if isinstance(val, dict):
                        hdf.attrs[key] = json.dumps(val)
                    else:
                        hdf.attrs[key] = val

        save_metadata(output, metadata)


