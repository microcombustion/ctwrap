"""This module handles batch cantera simulations variations.
Cantera based modules are pass to this module where they are run in batches.
see `adiabatic flame example <adiabatic_flame_example.ipynb>`_ or
`ignition_example <ignition_example.ipynb>`_.

 *Note:* Other cantera simulations module can be used with this module provided they followed the
 format in `minimal <minimal.py>`_.
 """

import os
from pathlib import Path
from copy import deepcopy
import importlib
import h5py
from ruamel import yaml
import warnings

from typing import Dict, Any, Optional, TypeVar, Union


# multiprocessing
import multiprocessing as mp
import queue  # imported for using queue.Empty exception

# ctwrap specific import
from .parser import _parse, _write, Parser
from .strategy import Strategy, Sequence, Matrix


supported = ('.h5', '.hdf', '.hdf5')

__all__ = ['Simulation', 'SimulationHandler']

indent1 = ' * '
indent2 = '   - '


class Simulation(object):
    """
    The Simulation class wraps modules into an object.
    Required module functions ``run``, ``save`` and
    ``defaults`` are passed through

    .. note:: :class:`Simulation` objects should be instantiated using
       :meth:`from_module` method.

    Attributes:
        data (dict): dictionary

    Arguments:
        module: handle name or handle to module running the simulation
        output: generated by `SimulationHandler`
    """

    def __init__(self, module: str, output: Dict[str, Any]=None):
        """Constructor for `Simulation` object."""

        assert isinstance(module, str), 'need module name'

        # ensure that module is well formed
        msg = 'module `{}` is missing attribute `{}`'
        for attr in ['defaults', 'run']:
            assert hasattr(importlib.import_module(module), attr), \
                msg.format(module, attr)

        self._module = module
        self._output = output
        self.data = None

    @classmethod
    def from_module(cls,
                    module: str,
                    output: Optional[Dict[str, Any]] = None) -> \
            Union['Simulation', Dict[str, Any], str]:
        """
        Alternative constructor for `Simulation` object.

        The :meth:`from_module` method is intended as the main route for the creation of
        `Simulation` objects. For example:

        .. code-block:: Python

           # creates a simulation object with the simualtion module `minimal`
           sim = ctwrap.Simulation.from_module(ctwrap.modules.minimal)

        Arguments:
           module (module): handle name or handle to module running the simulation
           output (dict):  output hdf file information generated by `SimulationHandler`
        """

        # create a name that reflect the module name (CamelCase)
        if isinstance(module, str):
            name = module.split('.')[-1]
        else:
            name = module.__name__.split('.')[-1]
            module = module.__name__
        name = ''.join([m.title() for m in name.split('_')])

        return type(name, (cls,), {})(module, output)

    def run(self, name: Optional[str] = 'defaults',
            config: Optional[Dict[str, Any]] = None,
            **kwargs: str) -> None:
        """
        Runs the simulation module's run method.

        This :meth:`run` method is used to call the simulation module's run method.
        If a simulation object ``sim`` was created with simulation module
        ``minimal``, then calls this :meth:`run` method calls ``run`` method in
        simulation module ``minimal``. A simple usage example is

        .. code-block:: Python

            # calls the run method in simulation module 'minimal`
            sim.run()

        Arguments:
           name (string): name of simulation run
           config (dict, optional): configuration
           **kwargs (optional): depends on implementation of __init__
        """

        self._module = importlib.import_module(self._module)

        if config is None:
            config = self._module.defaults()
        config = Parser(config)

        self.data = self._module.run(name, **config, **kwargs)
        self._module = self._module.__name__

    def defaults(self) -> Dict[str, Any]:
        """Pass-through returning simulation module defaults as a dictionary"""
        return self._module.defaults()

    def _save(self, mode="a", task=None, **kwargs: str) -> None:
        """
        Save simulation data (hidden)

        The :meth:`_save` is used to call the simulation module's save method.

        Arguments:
            **kwargs (optional): keyword arguments
        """

        if self._output is None:
            return

        filename = self._output['file_name']

        if filename is None:
            return

        filepath = self._output['path']
        formatt = "." + self._output['format']
        force = self._output['force_overwrite']

        if filepath is not None:
            filename = os.path.join(filepath, filename)

        # file check
        fexists = os.path.isfile(filename)

        if fexists:
            with h5py.File(filename, 'r') as hdf:
                for group in hdf.keys():
                    if group in self.data and mode == 'a' and not force:
                        msg = 'Cannot overwrite existing ' \
                              'group `{}` (use force to override)'
                        raise RuntimeError(msg.format(group))

        if formatt in supported:
            self._module = importlib.import_module(self._module)
            try:
                self._module.save(filename, self.data, task)
            except AttributeError:
                print("{} simulation module has no method 'save' but output format "
                      "was defined in configuration file".format(self._module.__name__))
                raise
            self._module = self._module.__name__
        else:
            raise ValueError("Invalid file format {}".format(formatt))

    def _save_metadata(self,
                       output: Optional[Dict[str, Any]] = None,
                       metadata: Optional[Dict[str, Any]] = None,
                       ) -> None:
        """
        Modules saves the input file as an attribute after the
        batch simulation has been completed

        This method calls the
        :py:func:`~ctwrap.parser.save_metadata` method.

        Arguments:
            metadata (dict): data to be saved
            output (dict): output file information
        """

        if output is None:
            output = self._output

        if metadata is None or output is None:
            return

        def save_metadata(output: Dict[str, Any],
                        metadata: Dict[str, Any]) -> None:
            """Function save metadata as attributes to file

            Arguments:
                output: file information
                metadata: metadata
            """

            oname = output['file_name']
            opath = output['path']
            formatt = output['format']
            force = output['force_overwrite']

            if oname is None:
                return
            if opath is not None:
                oname = os.path.join(opath, oname)

            with h5py.File(oname, 'r+') as hdf:
                for key, val in metadata.items():
                    if isinstance(val, dict):
                        hdf.attrs[key] = yaml.dump(val, Dumper=yaml.SafeDumper)
                    else:
                        hdf.attrs[key] = val


        save_metadata(output, metadata)


class SimulationHandler(object):
    """
    Class handling parameter variations.
    Class adds methods to switch between multiple configurations.

    .. note:: :class:`SimulationHandler` objects should be
        instantiated using the :meth:`from_yaml` method.

    An example of a minimal yaml configuration is:

    .. code-block:: YAML

        strategy: # variation data
          sequence:
            sleep: [0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8]
        defaults: # default parameters to run the modules
          sleep: 0.2

    Attributes:
       verbosity (int): verbosity level

    Arguments:
       defaults: Dictionary containing simulation defaults
       strategy: Dictionary specifying batch simulation strategy
       output: Dictionary specifying file output
       verbosity: Verbosity level
    """

    def __init__(self,
                 defaults: Dict[str, Any],
                 strategy: Optional[Dict[str, Any]]=None,
                 output: Optional[Dict[str, Any]]=None,
                 verbosity: Optional[int]=0,
                 variation: Optional[Dict[str, Any]]=None):
        """Constructor for `SimulationHandler` object."""

        # parse arguments
        self._defaults = defaults
        self._variation = variation
        self._output = output
        self.verbosity = verbosity

        if variation and isinstance(variation, dict):
            self._strategy = Sequence.from_legacy(variation)
            warnings.warn("Old implementation", PendingDeprecationWarning)
        elif strategy and isinstance(strategy, dict):
            self._strategy = Strategy.load(**strategy)
        else:
            raise ValueError("Missing or invalid argument: need 'strategy' or 'variation' dictionary")

        if not isinstance(self._strategy, Sequence):
            raise NotImplementedError("Todo")
        # todo: replace hard coded strategy with tasks handled by Strategy objects
        self._entry, self._values = list(self._strategy.sweep.items())[0]

        # vals = self._variation_tuple[1]
        if self.verbosity and self._values is not None:
            print('Simulations for entry `{}` with values: {}'.format(
                self._entry, self._values))

        if self._output is not None:
            if variation:
                var = variation.copy()
            else:
                var = strategy.copy()
            var['tasks'] = [t for t in self.tasks]
            var['tasks'].sort()

            # assemble information
            self._metadata = {
                'defaults': self._defaults,
                'variation': var,
            }

    @classmethod
    def from_yaml(cls, yaml_file: str,
                  name: Optional[str] = None,
                  path: Optional[str] = None,
                  **kwargs: str):
        """
        Alternate constructor using YAML file as input.

        The :meth:`from_yaml` method is intended as the main route for the creation of
        `SimulationHandler` objects.

        .. code-block:: Python

           # creates a simulationHandler object
           sh = ctwrap.SimulationHandler.from_yaml('minimal.yaml')

        Arguments:
           yaml_file (string): yaml file
           name (string): output name (overrides yaml)
           path (string): file path (both yaml and output)
           ** kwargs (optional): dependent on implementation (e.g. verbosity, reacting)
        """

        # load configuration from yaml
        fname = Path(yaml_file)
        if path is not None:
            fname = Path(path) / fname

        with open(fname) as stream:
            content = yaml.load(stream, Loader=yaml.SafeLoader)

        output = content.get('output', {})

        # naming priorities: keyword / yaml / automatic
        if name is None:
            name = '{}'.format(Path(yaml_file).parents[0] / fname.stem)
            name = output.get('name', name)

        return cls.from_dict(content, name=name, path=path, **kwargs)

    @classmethod
    def from_dict(cls, content: Dict[str, Any],
                  name: Optional[str] = None,
                  path: Optional[str] = None,
                  **kwargs: str) -> \
            Union['SimulationHandler', Dict[str, Any], str]:
        """
        Alternate constructor using a dictionary as input.

        Arguments:
           content (dict): dictionary from yaml input
           name (string): output name (overrides yaml)
           path (string): output path (overrides yaml)
           ** kwargs (optional): dependent on implementation (e.g. verbosity, reacting)
        """
        assert 'ctwrap' in content, 'obsolete yaml file format'
        assert 'defaults' in content, 'obsolete yaml file format'
        defaults = content['defaults']
        strategy = content.get('strategy', None)
        variation = content.get('variation', None)
        output = content.get('output', None)

        output = cls._parse_output(output, fname=name, fpath=path)

        return cls(defaults, strategy=strategy, output=output, variation=variation, **kwargs)

    @staticmethod
    def _parse_output(dct: Dict[str, Any],
                      fname: Optional[str] = None,
                      fpath: Optional[str] = None):
        """
        Parse output dictionary (hidden function)
        Overrides defaults with keyword arguments.

        Arguments:
           dct (dict, optional): dictionary from yaml input
           fname (name, optional): filename (overrides yaml)
           fpath (string, optional): output path (overrides yaml)

        Returns:
            Dictionary containing output information
        """

        if dct is None:
            return None

        # establish defaults
        out = dct.copy()
        out['path'] = None  # should never be specified inside of yaml
        if 'format' not in out:
            out['format'] = ''
        if 'force_overwrite' not in out:
            out['force_overwrite'] = False

        fformat = out['format']

        # file name keyword overrides dictionary
        if fname is not None:

            # fname may contain path information
            head, fname = os.path.split(fname)
            if len(head) and fpath is not None:
                raise RuntimeError('contradictory specification')
            elif len(head):
                fpath = head

            fname, ext = os.path.splitext(fname)
            if ext in supported:
                fformat = ext

            out['name'] = fname

        # file path keyword overrides dictionary
        if fpath is not None:
            out['path'] = fpath

        # file format
        if fformat is None:
            pass
        elif len(fformat):
            out['format'] = fformat.lstrip('.')
        else:
            out['format'] = 'h5'

        if fformat is None:
            out['file_name'] = None
        else:
            out['file_name'] = '.'.join([out['name'], out['format']])

        return out

    def __iter__(self):
        """Returns itself as iterator"""

        for task in self.tasks:
            yield task

    def __getitem__(self, task: str):
        return self.configuration(task)

    def configuration(self, task: str):
        """
        Return configuration.

        Argument:
            task(str) : task to do

        Return:
            updated configuration dictionary based on the task
        """

        value = self.tasks.get(task, None)
        assert task is not None, 'invalid value'

        out = deepcopy(self._defaults)

        # locate and replace entry in nested dictionary (recursive)
        def replace_entry(nested, key_list, value):
            sub = nested[key_list[0]]
            if len(key_list) == 1:
                if isinstance(sub, list):
                    sub[0] = value
                elif isinstance(sub, str):
                    _, unit = _parse(sub)
                    sub = _write(value, unit)
                else:
                    sub = value
            else:
                sub = replace_entry(sub, key_list[1:], value)
            nested[key_list[0]] = sub
            return nested

        value = self.tasks[task]
        entry = self._entry.split('.')

        return replace_entry(out, entry, value)

        # return out

    @property
    def verbose(self):
        """verbosity"""
        return self.verbosity > 0

    @property
    def output_name(self):
        """return output name"""
        if self._output['path'] is None:
            return self._output['file_name']
        else:
            return os.path.join(self._output['path'], self._output['file_name'])

    @property
    def tasks(self):
        """tasks defined in terms of the variation entry and values"""
        e = self._entry
        return {'{}_{}'.format(e, v): v for v in self._values}

    def run_task(self, sim: Simulation, task: str, **kwargs: str):
        """
        Function to run a specific task.

        The :meth:`run_task` method calls the module's run and save method to run and
        save the resulting output object and also afterwards calls
        :py:func:`~ctwrap.parser._save_metadata` to save metadata.
        A simple usage example is:

        If a simulationHandler object ``sh`` was created from ``minimal.yaml``.
        This :meth:`run_task` method takes ``sim``, a simulation object created using
        simulation module ``minimal``, and a task see :meth:`tasks` method.
        This :meth:`run_task` method runs the task calling the ``run`` method in
        simulation module ``minimal``, save the resulting output using
        the ``save``  method in simulation module ``minimal`` and finally
        save the `metatada` using :py:func:`~ctwrap.parser.save_metadata` method.

        .. code-block:: Python

            # Runs the task `sleep_0.4` using `sim` object
            sh.run_task(sim, 'sleep_0.4' )

        Arguments:
            sim (object): instance of Simulation class
            task (str): task to do
            ** kwargs (optional): dependent on implementation
            (e.g. verbosity, reacting)
        """

        assert task in self.tasks, 'unknown task `{}`'.format(task)

        # create a new simulation object
        obj = Simulation.from_module(sim._module, self._output)

        # run simulation
        config = self.configuration(task)

        obj.run(task, config, **kwargs)
        obj._save(task=task)
        if self._output is not None:
            obj._save_metadata(self._output, self._metadata)

    def run_serial(self,
                   sim: Simulation,
                   verbosity: Optional[int] = None,
                   **kwargs: str) -> bool:
        """
        Run variation in series.

        The :meth:`run_serial` method runs all the variations in the input
        file serially. A simple usage example is:

        If a simulationHandler object ``sh`` was created from ``minimal.yaml``.
        This :meth:`run_serial` method takes ``sim``, a simulation object created using
        simulation module ``minimal``. This :meth:`run_serial` method
        runs all the variations in minimal configuration file calling the ``run``
        method in simulation module ``minimal``,  save the resulting output using the
        ``save``  method in simulation module ``minimal`` serially and finally
        save the `metatada` using :py:func:`~ctwrap.parser.save_metadata` method.

        .. code-block:: Python

            # Runs all the variations serially
            sh.run_serial(sim)

        Arguments:
            sim (object): instance of Simulation class
            verbosity (int, optional): verbosity
            ** kwargs (optional): dependent on implementation (e.g. verbosity, reacting)

        Returns:
            return True when task is completed
        """

        assert isinstance(sim, Simulation), 'need simulation object'

        if verbosity is None:
            verbosity = self.verbosity

        # create a new simulation object
        obj = Simulation.from_module(sim._module, self._output)

        tasks = [t for t in self.tasks]
        tasks.sort()
        for t in tasks:
            if verbosity > 0:
                print(indent1 + 'processing `{}`'.format(t))

            # run simulation
            config = self.configuration(t)
            obj.run(t, config, **kwargs)
            obj._save(task=t)
        if self._output is not None:
            obj._save_metadata(self._output, self._metadata)
        return True

    def run_parallel(self,
                     sim: Simulation,
                     number_of_processes: Optional[int] = None,
                     verbosity: Optional[str] = None,
                     **kwargs: str) -> bool:
        """
        Run variation using multiprocessing.

        The :meth:`run_parallel` method runs all the variations in the input
        file in parallel using
        `python multiprocessing <https://docs.python.org/3/library/multiprocessing.html>`_.
        A minimal example is:

        If a simulationHandler object ``sh`` was created from ``minimal.yaml``.
        The :meth:`run_parallel` method takes ``sim``, a simulation object created using
        simulation module ``minimal``. The :meth:`run_parallel` method
        runs all the variations in minimal configuration file calling the ``run``
        method in simulation module ``minimal``,  save the resulting output using the
        ``save``  method in simulation module ``minimal`` in parallel and finally
        save the `metatada` using :py:func:`~ctwrap.parser.save_metadata` method.

         .. code-block:: Python

            # Runs all the variations in parallel
                sh.run_parallel(sim)

        Arguments:
            sim (object): instance of Simulation class
            number_of_processes(int, optional): number of processes
            verbosity(int, optional): verbosity level
            ** kwargs (optional): dependent on implementation (e.g. verbosity, reacting)

        Returns:
            return True when task is completed
        """

        assert isinstance(sim, Simulation), 'need simulation object'

        if number_of_processes is None:
            number_of_processes = mp.cpu_count() // 2

        if verbosity is None:
            verbosity = self.verbosity

        if verbosity > 0:
            print(indent1 + 'running simulation using ' +
                  '{} cores'.format(number_of_processes))

        # set up queues
        tasks_to_accomplish = mp.Queue()
        finished_tasks = mp.Queue()
        tasks = [t for t in self.tasks]
        tasks.sort()
        for t in tasks:
            config = self.configuration(t)
            tasks_to_accomplish.put((t, config, kwargs))

        lock = mp.Lock()

        # creating processes
        processes = []
        for w in range(number_of_processes):
            p = mp.Process(
                target=worker,
                args=(tasks_to_accomplish, finished_tasks, sim._module, lock,
                      self._output, verbosity))
            processes.append(p)
            p.start()

        # completing process
        for p in processes:
            p.join()

        # print the output
        while not finished_tasks.empty():
            msg = finished_tasks.get()
            if verbosity > 1:
                print(indent2 + msg)

        if self._output is not None:
            if verbosity > 1:
                print(indent1 + "Appending metadata")
            sim._save_metadata(self._output, self._metadata)

        return True


def worker(tasks_to_accomplish, tasks_that_are_done, module: str, lock,
           output: Dict[str, Any],
           verbosity: int) -> True:
    """
    Worker function for the `:meth: `run_parallel` method.

    Arguments:
        tasks_to_accomplish (queue): multiprocessing queue of remaining task
        tasks_that_are_done (queue): multiprocessing queue of complted task
        module (str): name of handler to be run
        lock (lock): multiprocessing lock
        output (dict): dictionary containing output information
        metadata (dict): dictionary containing metadata
        verbosity (int): verbosity level

    Returns:
        True when tasks are completed

    """

    this = mp.current_process().name

    if verbosity > 1:
        print(indent2 + 'starting ' + this)

    while True:
        try:
            # retrieve next simulation task
            task, config, kwargs = tasks_to_accomplish.get_nowait()

        except queue.Empty:
            # no tasks left
            if verbosity > 1:
                print(indent2 + 'terminating ' + this)
            break

        else:
            obj = Simulation.from_module(module, output)
            # perform task
            msg = indent1 + 'processing `{}` ({})'
            if verbosity > 0:
                print(msg.format(task, this))
            obj.run(task, config, **kwargs)
            with lock:
                obj._save(task=task)
            msg = 'case `{}` completed by {}'.format(task, this)
            tasks_that_are_done.put(msg)

    return True
